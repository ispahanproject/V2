<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Descent Planner - Fixed</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script src="../js/waypoints.js"></script>
    <script src="../js/navaids.js"></script>

    <style>
        :root { --bg:#000; --green:#00ff00; --cyan:#00ffff; --magenta:#ff00ff; --yellow:#ffcc00; --panel:rgba(20,20,20,0.95); }
        body { margin:0; background:var(--bg); color:var(--green); font-family:'Consolas',monospace; display:flex; flex-direction:column; height:100vh; overflow:hidden; }
        #map-container { flex:60; border-bottom:2px solid #333; position:relative; background:#111; }
        #chart-container { flex:40; padding:10px; background:var(--bg); }

        /* FMS PANEL */
        .fms-overlay { 
            position:absolute; top:20px; right:20px; z-index:1000; 
            background:var(--panel); border:1px solid #e0e0e0; 
            padding:15px; border-radius:4px; min-width:260px; 
        }
        .data-row { display:flex; justify-content:space-between; margin-bottom:4px; font-weight:bold; }
        .label { color:var(--cyan); } .val { color:var(--green); } .mag { color:var(--magenta); }
        
        .search-box { display:flex; gap:5px; margin-bottom:10px; border-bottom:1px dashed #555; padding-bottom:10px; }
        .fms-input { background:#000; border:1px solid #00ff00; color:#fff; padding:5px; flex:1; text-transform:uppercase; font-family:monospace; }
        .btn-act { background:#006600; color:#fff; border:none; cursor:pointer; padding:0 10px; font-weight:bold; }
        .btn-clr-all { float:right; background:#cc0000; color:#fff; border:1px solid #ff3333; font-size:0.7em; padding:2px 6px; cursor:pointer; font-weight:bold; margin-left:10px; }

        /* MEASURE PANEL */
        .measure-box {
            position:absolute; top:20px; left:60px; z-index:1000;
            background:var(--panel); border:1px solid var(--yellow);
            padding:10px; border-radius:4px; min-width:240px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
        }
        .m-title { color:var(--yellow); font-weight:bold; border-bottom:1px solid #555; margin-bottom:8px; font-size:0.9em; }
        .measure-input-row { display:flex; margin-bottom:5px; gap:5px; align-items:center; }
        .m-ipt { background:#000; border:1px solid #555; color:#fff; padding:3px; flex:2; font-family:monospace; text-transform:uppercase; }
        .m-ipt-alt { background:#000; border:1px solid #555; color:#fff; padding:3px; flex:1; font-family:monospace; text-align:right; }
        .m-lbl { color:#aaa; font-size:0.8em; width:35px; }
        .m-res-area { margin-top:8px; padding-top:5px; border-top:1px dashed #555; display:grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size:0.9em; }
        .m-res-item { background: #222; padding: 2px 5px; border-radius: 3px; }
        .m-res-val { color:var(--cyan); font-weight:bold; display: block; font-size: 1.1em;}
        .mode-check { margin-top:8px; font-size:0.75em; color:#ccc; display:block; cursor:pointer; border-top:1px solid #333; padding-top:5px; }

        /* POPUP & OTHERS */
        .editor-popup input { width:100%; box-sizing:border-box; background:#333; color:#fff; border:1px solid #555; margin-bottom:4px; }
        .editor-btn-row { display:flex; gap:5px; margin-top:5px; }
        .btn-upd { background:#006600; color:#fff; border:none; padding:5px; width:100%; cursor:pointer; }
        .btn-del { background:#660000; color:#fff; border:none; padding:5px; width:40%; cursor:pointer; }
        .rad-label { background:transparent; border:none; box-shadow:none; color:#00ff00; font-size:12px; font-weight:bold; text-shadow:2px 2px 0 #000; }
        .measure-label { background:rgba(0,0,0,0.8); border:1px solid var(--yellow); color:var(--yellow); font-size:11px; font-weight:bold; }
        .leaflet-container { background:#050505; }
        .leaflet-popup-content-wrapper { background:var(--panel); color:var(--green); border:1px solid var(--green); }
        .leaflet-tooltip-left:before, .leaflet-tooltip-right:before { border: none !important; }

        /* ★追加: WPTリスト表示用 */
.wpt-list-container {
    max-height: 150px; /* 長くなったらスクロール */
    overflow-y: auto;
    border: 1px solid #333;
    margin-bottom: 10px;
    background: #000;
}
.wpt-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 2px 5px;
    border-bottom: 1px solid #333;
    font-size: 0.85em;
}
.wpt-row:last-child { border-bottom: none; }
.wpt-name { color: #00ff00; font-weight: bold; }
.wpt-alt { color: #aaa; margin-left: 5px; font-size: 0.9em; }

/* 小さな移動ボタン */
.btn-move {
    background: #333; color: #fff; border: 1px solid #555;
    cursor: pointer; font-size: 0.8em; padding: 0 5px; margin-left: 2px;
}
.btn-move:hover { background: #555; }
.btn-move:disabled { color: #555; border-color: #222; cursor: default; background: #111; }

/* ★追加: リスト内の高度入力欄用 */
.wpt-alt-input {
    width: 60px;
    background: #111;
    color: #fff;
    border: 1px solid #444;
    font-family: 'Consolas', monospace;
    font-size: 0.9em;
    text-align: right;
    padding: 1px 3px;
    margin-left: 5px;
}
.wpt-alt-input:focus {
    border-color: #00ff00;
    outline: none;
}

/* ★追加: 地図上のレグ距離ラベル */
.leg-dist-label {
    color: #00ffff; /* シアン色 */
    font-size: 11px;
    font-family: 'Consolas', monospace;
    font-weight: bold;
    text-align: center;
    text-shadow: 2px 2px 0 #000; /* 黒縁取りで読みやすく */
    white-space: nowrap;
}

/* ★追加: 測定結果のアイコン背景を透明にする */
.measure-result-icon {
    background: transparent !important;
    border: none !important;
}

/* ★追加: リスト内の削除ボタン */
.btn-del-list {
    background: #660000;
    color: #fff;
    border: 1px solid #ff3333;
    cursor: pointer;
    font-size: 0.8em;
    padding: 0 6px;
    margin-left: 5px;
    font-weight: bold;
}
.btn-del-list:hover {
    background: #cc0000;
}

/* ★追加: TOD表示の調整 */
#disp-tod {
    font-size: 0.8em; /* 文字を少し小さくして収まりよくする */
    white-space: nowrap; /* 勝手な改行を防ぐ */
}

.icon-fix {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    width: 10px !important;
    height: 10px !important;
    /* 重要: 中の三角形を絶対位置で制御するための基準にする */
    position: relative !important;
}

/* 三角形本体: 親の 10px 四方のど真ん中に強制配置 */
.icon-fix::after {
    content: '';
    position: absolute;
    /* 親要素(10px)の 50% の位置（中心）に配置 */
    left: 50%;
    top: 50%;
    /* 自身のサイズの半分だけ戻すことで、図形の重心を [5, 5] に一致させる */
    transform: translate(-50%, -50%);
    
    /* 三角形のサイズ指定（以前より一回り小さく設定） */
    width: 0;
    height: 0;
    border-left: 6px solid transparent;  /* 底辺 8px の半分 */
    border-right: 6px solid transparent; /* 底辺 8px の半分 */
    border-bottom: 9px solid #00ff00;    /* 高さ 7px */
    
    display: block !important;
}
.icon-vor { background:#00ffff; border:1px solid #000; width:12px; height:12px; transform:rotate(45deg); box-shadow:0 0 5px #00ffff; }
.icon-apt { background:transparent; border:2px solid #ff00ff; border-radius:50%; width:14px; height:14px; box-shadow:0 0 5px #ff00ff; }
    </style>
</head>

<body>

    <a href="../index.html" style="
    position: absolute; top: 20px; left: 10px; z-index: 2000;
    background: rgba(20, 20, 20, 0.95);
    border: 1px solid #00ff00; border-radius: 4px;
    color: #00ff00; text-decoration: none;
    padding: 6px 10px; font-weight: bold; font-family: monospace; font-size: 14px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.8);
">HOME</a>

    <div id="map-container">
        
        <div class="measure-box">
            <div class="m-title">MEASURE & PATH TOOL</div>
            
            <div class="measure-input-row">
                <span class="m-lbl">FROM</span>
                <input type="text" id="m-from" class="m-ipt" placeholder="WPT" onkeydown="checkMeasureEnter(event)">
                <input type="number" id="m-from-alt" class="m-ipt-alt" placeholder="ALT(ft)" step="100">
            </div>
            
            <div class="measure-input-row">
                <span class="m-lbl">TO</span>
                <input type="text" id="m-to" class="m-ipt" placeholder="WPT" onkeydown="checkMeasureEnter(event)">
                <input type="number" id="m-to-alt" class="m-ipt-alt" placeholder="ALT(ft)" step="100">
            </div>

            <div style="text-align:right;">
                <button onclick="calcMeasure()" style="background:var(--yellow); border:none; cursor:pointer; font-weight:bold; padding:2px 8px;">CALC</button>
            </div>

            <div class="m-res-area">
                <div class="m-res-item">DIST <span id="m-dist" class="m-res-val">---</span></div>
                <div class="m-res-item">BRG <span id="m-brg" class="m-res-val" style="color:var(--magenta)">---</span></div>
                <div class="m-res-item" style="grid-column: span 2; text-align:center;">
                    VNAV PATH <span id="m-path" class="m-res-val" style="color:#ff3333; font-size:1.3em;">---</span>
                </div>
            </div>

            <label class="mode-check">
                <input type="checkbox" id="chk-measure-mode" onclick="toggleMeasureMode()"> 
                Measure Mode (Single Click)
            </label>
        </div>

        <div class="fms-overlay">
            <div style="color:#fff; font-weight:bold; border-bottom:1px solid #555; margin-bottom:10px;">
                FMS UNIT
                <button class="btn-clr-all" onclick="clearAllWpt()">CLR ALL</button>
            </div>
            
            <div class="search-box">
                <input type="text" id="dest-search" class="fms-input" placeholder="SET DEST (WPT)" onkeydown="if(event.key==='Enter') setDest()">
                <button class="btn-act" onclick="setDest()">SET</button>
            </div>

            <div class="search-box">
                <input type="text" id="grid-center-input" class="fms-input" placeholder="GRID CTR (WPT)" onkeydown="if(event.key==='Enter') setGridCenter()">
                <button class="btn-act" onclick="setGridCenter()">SET</button>
            </div>

            <div class="search-box">
                <input type="text" id="wpt-search" class="fms-input" placeholder="ADD WPT" onkeydown="if(event.key==='Enter') addFromDb()">
                <button class="btn-act" onclick="addFromDb()">ADD</button>
            </div>

            <div class="wpt-list-container" id="fms-seq-list"></div>

            <div class="data-row" style="align-items:center; margin-top:10px; border-top:1px dashed #555; padding-top:5px;">
                <span class="label">CRZ ALT</span>
                <div style="display:flex; align-items:center;">
                    <input type="number" id="user-crz-alt" class="fms-input" style="width:60px; text-align:right; padding:2px;" value="41000" step="1000" onchange="updateSys()">
                    <span class="val" style="margin-left:5px;">FT</span>
                </div>
            </div>

            <div class="data-row"><span class="label">DTG</span> <span class="val mag" id="disp-dtg">--- NM</span></div>
            <div class="data-row"><span class="label">TOD</span> <span class="val" id="disp-tod">--- NM</span></div>
            
            <div style="font-size:0.7em; color:#aaa; margin-top:8px; text-align:right;">
                *Double Click Map to Add WPT
            </div>
        </div>

    </div>

    <div id="chart-container"><canvas id="vnavChart"></canvas></div>

<script>
    // --- 初期データ ---
    let flightPlan = [
        { id: "SPENS",lat: 34.71482,lon: 139.00152, altConstraint: 22000, type: 'ABOVE' },
        
        { id: "RJTT",  lat: 35.549, lon: 139.779, altConstraint: 21,    type: 'RWY' }
    ];
    let CRUISE_ALT = 41000;

    // --- 計算関数 ---
    const R_E = 3440.06; const DEG=180/Math.PI; const RAD=Math.PI/180;
    function getDist(l1,ln1,l2,ln2){
        const dl=(l2-l1)*RAD; const dln=(ln2-ln1)*RAD;
        const a=Math.sin(dl/2)**2 + Math.cos(l1*RAD)*Math.cos(l2*RAD)*Math.sin(dln/2)**2;
        return R_E*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    }
    function getBrg(l1,ln1,l2,ln2){
        const y=Math.sin((ln2-ln1)*RAD)*Math.cos(l2*RAD);
        const x=Math.cos(l1*RAD)*Math.sin(l2*RAD)-Math.sin(l1*RAD)*Math.cos(l2*RAD)*Math.cos((ln2-ln1)*RAD);
        return (Math.atan2(y,x)*DEG+360)%360;
    }
    function getPathAngle(alt1, alt2, distNM) {
        if(distNM <= 0) return 0;
        const hDiff = alt1 - alt2;
        const distFt = distNM * 6076;
        return Math.atan(hDiff / distFt) * (180 / Math.PI);
    }
    function getSnapPoint(lat, lon, isMeasureMode) {
        let name = "WPT"+Math.floor(Math.random()*999);
        let sLat=lat, sLon=lon;
        if(typeof WP_DB !== 'undefined'){
            let minDist = 10.0;
            for(let key in WP_DB){
                const d = getDist(lat, lon, WP_DB[key].lat, WP_DB[key].lon);
                if(d < 5.0 && d < minDist){ minDist = d; name = key; sLat = WP_DB[key].lat; sLon = WP_DB[key].lon; }
            }
        }
        if(name.startsWith("WPT") && isMeasureMode) name = `${lat.toFixed(3)},${lon.toFixed(3)}`;
        return {lat: sLat, lon: sLon, name: name};
    }
    // ★追加: FIX(WP_DB) と NAV(NAV_DB) を統合して検索する関数
    function searchPoint(ident) {
        ident = ident.toUpperCase().trim();
        if (!ident) return null;

        let candidate = null;
        if (typeof NAV_DB !== 'undefined' && NAV_DB[ident]) {
            candidate = NAV_DB[ident];
        } else if (typeof WP_DB !== 'undefined' && WP_DB[ident]) {
            candidate = WP_DB[ident];
        }

        if (!candidate) return null;

        // 候補を配列化
        const list = Array.isArray(candidate) ? candidate : [candidate];

        // 重複がある場合、DESTに一番近いもの「1つだけ」を抽出
        let best = list[0];
        if (list.length > 1) {
            let destLat = 35.549, destLon = 139.779;
            if (flightPlan.length > 0) {
                const dest = flightPlan[flightPlan.length - 1];
                destLat = dest.lat;
                destLon = dest.lon;
            }
            let minDist = Infinity;
            list.forEach(pt => {
                const d = getDist(destLat, destLon, pt.lat, pt.lon);
                if (d < minDist) {
                    minDist = d;
                    best = pt;
                }
            });
        }

        // 重要: 座標(lat, lon)と種別(type)を単一のオブジェクトとして返す
        return { 
            id: ident, 
            lat: best.lat, 
            lon: best.lon, 
            type: best.type || 'FIX' 
        };
    }

    function resolveMInput(val) {
        val = val.toUpperCase().trim();
        if(val==="") return null;

        // ★修正: searchPoint を使うように変更
        const pt = searchPoint(val);
        if(pt) return { lat: pt.lat, lon: pt.lon, name: pt.id };

        if(val.includes(",")){ const p=val.split(","); return {lat:parseFloat(p[0]), lon:parseFloat(p[1]), name:"COORD"}; }
        return null;
    }



    function checkMeasureEnter(e) { if(e.key==='Enter') calcMeasure(); }

    // --- Leaflet & Chart ---
    const map = L.map('map-container', { doubleClickZoom: false }).setView([35.5, 139.8], 9);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',{attribution:'©CARTO'}).addTo(map);
    
    let polyline = null; 
    let markers = []; 
    let dmeGrp = L.layerGroup().addTo(map); 
    let measureLayer = L.layerGroup().addTo(map);

    // ★追加: レグ距離表示用レイヤー
    let distLabelLayer = L.layerGroup().addTo(map);
    

    Chart.defaults.color='#00ff00'; Chart.defaults.borderColor='#333';
    
    const labelPlugin = {
        id: 'wptLabels',
        afterDatasetsDraw(chart) {
            const {ctx} = chart;
            ctx.save();
            ctx.font = 'bold 12px Consolas';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            // 1. WPT名 (Dataset 0: ピンクの線) の描画
            const meta0 = chart.getDatasetMeta(0);
            ctx.fillStyle = '#ffffff';
            meta0.data.forEach((element, index) => {
                const dataPoint = chart.data.datasets[0].data[index];
                if (dataPoint && dataPoint.name) {
                    ctx.fillText(dataPoint.name, element.x, element.y - 10);
                }
            });

            // 2. TODラベル (Dataset 1: 3° / Dataset 2: 4°) の描画
            // updateSysで作ったデータは [RWY, TOD, CRZ] の3点構成なので、真ん中(index 1)がTOD
            [1, 2].forEach(dsIdx => {
                const meta = chart.getDatasetMeta(dsIdx);
                // データが存在し、かつ点が2個以上ある場合のみ描画
                if (!meta.data || meta.data.length < 2) return;

                const element = meta.data[1]; // 2番目の点 = TOD
                
                // ラベル文字と色を設定
                const label = (dsIdx === 1) ? "TOD 3°" : "TOD 4°";
                const color = (dsIdx === 1) ? "#00ff00" : "#ffcc00"; // 3°=緑, 4°=黄

                ctx.fillStyle = color;
                // ポイントの少し上に描画
                ctx.fillText(label, element.x, element.y - 10);
            });

            ctx.restore();
        }
    };

    const segmentPlugin = {
        id: 'segmentLabels',
        afterDatasetsDraw(chart) {
            const {ctx} = chart; const meta = chart.getDatasetMeta(0); const data = chart.data.datasets[0].data;
            ctx.save(); ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = '11px Consolas';
            for(let i = 0; i < meta.data.length - 1; i++) {
                const p1 = meta.data[i]; const p2 = meta.data[i+1]; const d1 = data[i]; const d2 = data[i+1];
                const midX = (p1.x + p2.x) / 2; const midY = (p1.y + p2.y) / 2;
                const dist = Math.abs(d1.x - d2.x); const altDiff = d1.y - d2.y; 
                let angle = 0;
                if(dist > 0.1) angle = Math.atan(altDiff / (dist * 6076)) * (180 / Math.PI);
                if (dist > 0.5) {
                    ctx.fillStyle = '#aaaaaa'; ctx.fillText(dist.toFixed(1) + "NM", midX, midY - 7);
                    ctx.fillStyle = Math.abs(angle) > 3.5 ? '#ff3333' : '#00ff00';
                    ctx.fillText(angle.toFixed(1) + "°", midX, midY + 7);
                }
            }
            ctx.restore();
        }
    };

    const vChart = new Chart(document.getElementById('vnavChart'), {
        type:'scatter',
        data:{ datasets:[
            {label:'PATH', borderColor:'#f0f', showLine:true, borderWidth:3, tension:0, pointRadius:5, pointBackgroundColor:'#f0f'},
            {label:'3°', borderColor:'#0c0', showLine:true, borderDash:[5,5], pointRadius:0, borderWidth:1},
            {label:'4°', borderColor:'#fc0', showLine:true, borderDash:[2,2], pointRadius:0, borderWidth:1}
        ]},
        options:{
            responsive:true, maintainAspectRatio:false,
            scales:{ x:{reverse:true, type:'linear', grid:{color:'#333'}}, y:{min:0, suggestedMax:15000, grid:{color:'#333'}} },
            plugins:{legend:{display:false}}
        },
        plugins: [labelPlugin, segmentPlugin]
    });

    // --- システム更新 ---
    // --- システム更新 (CRZ ALT変更対応版) ---
    function updateSys() {
        if(flightPlan.length === 0) return;

        // 1. ユーザー入力の巡航高度を取得して更新
        const altInput = document.getElementById('user-crz-alt');
        if(altInput) {
            const val = parseInt(altInput.value);
            // 有効な数値なら CRUISE_ALT を更新
            if(!isNaN(val) && val > 0) CRUISE_ALT = val;
        }

        // 2. 各区間の距離(leg)と残距離(dtg)を再計算
        let total=0;
        for(let i=0; i<flightPlan.length-1; i++){
            const d=getDist(flightPlan[i].lat, flightPlan[i].lon, flightPlan[i+1].lat, flightPlan[i+1].lon);
            flightPlan[i].leg=d; total+=d;
        }
        flightPlan[flightPlan.length-1].leg=0;
        let acc=0;
        flightPlan.forEach((p,i)=>{ p.dtg=total-acc; if(i<flightPlan.length-1)acc+=p.leg; });

        document.getElementById('disp-dtg').innerText = total.toFixed(1)+" NM";

        // 3. TOD計算 (3度パス & 4度パス)
        const rwyAlt = flightPlan[flightPlan.length-1].altConstraint||0;
        
        // 3度: 1NMあたり約318ft
        const tod3 = (CRUISE_ALT - rwyAlt) / 318.4;
        // 4度: 1NMあたり約425ft
        const tod4 = (CRUISE_ALT - rwyAlt) / 424.9;

        // 表示更新
       document.getElementById('disp-tod').innerHTML = 
            `<span style="color:#00ff00">3°PATH : ${tod3.toFixed(0)}(nm)</span> / <span style="color:#ffcc00">4°PATH : ${tod4.toFixed(0)}(nm)</span>`;
        

        // 4. 地図上のルート更新
        markers.forEach(m=>map.removeLayer(m)); markers=[];
        if(polyline) map.removeLayer(polyline);
        polyline = L.polyline(flightPlan.map(p=>[p.lat,p.lon]), {color:'#f0f', weight:3}).addTo(map);

        // 5. VNAVチャート更新
        const maxX = Math.max(total, tod3) + 10;

        // データセット0: フライトプラン (高度制限)
        vChart.data.datasets[0].data = flightPlan.map(p=>({x:p.dtg, y:p.altConstraint||null, name:p.id})).filter(d=>d.y!==null);
        
        // データセット1: 3°パス (緑)
        vChart.data.datasets[1].label = '3° PATH';
        vChart.data.datasets[1].borderColor = '#00ff00';
        vChart.data.datasets[1].borderDash = [5, 5];
        vChart.data.datasets[1].data = [
            {x:0, y:rwyAlt}, 
            {x:tod3, y:CRUISE_ALT}, 
            {x:maxX, y:CRUISE_ALT}
        ]; 
        
        // データセット2: 4°パス (オレンジ/黄色)
        vChart.data.datasets[2].label = '4° PATH';
        vChart.data.datasets[2].borderColor = '#ffcc00';
        vChart.data.datasets[2].borderDash = [2, 2];
        vChart.data.datasets[2].data = [
            {x:0, y:rwyAlt}, 
            {x:tod4, y:CRUISE_ALT}, 
            {x:maxX, y:CRUISE_ALT}
        ]; 
        
        // グラフのY軸最大値を巡航高度に合わせて調整
        vChart.options.scales.x.max = maxX;
        vChart.options.scales.y.suggestedMax = CRUISE_ALT + 2000;
        vChart.update();
        
        // 6. その他更新
        initMarkers();
        renderWptList();
        drawMapLegDistances();

        drawGrid();
    }

    function initMarkers() {
        markers.forEach(m => map.removeLayer(m));
        markers = [];

        flightPlan.forEach((p, i) => {
            const isRwy = (p.type === 'RWY' || p.type === 'APT');
            
            let iconClass = 'icon-fix'; 
            let iSize = [10, 10]; 
            // アンカーを [横の半分, 縦の半分より少し下] に微調整
            // これにより、三角形の重心がルートの結節点と一致します
            let iAnchor = [5, 5];

            if (p.type === 'VOR' || p.type === 'NDB') iconClass = 'icon-vor';
            if (p.type === 'APT' || p.type === 'RWY') iconClass = 'icon-apt';

            // ★修正: 三角形の中心を座標に合わせる設定
            const customIcon = L.divIcon({
                className: iconClass,
                iconSize: iSize,
                iconAnchor: iAnchor, // ここを適用
                html: ''
            });

            if (isNaN(p.lat) || isNaN(p.lon)) return;

            const m = L.marker([p.lat, p.lon], {
                draggable: !isRwy, 
                title: p.id,
                icon: customIcon
            }).addTo(map);

            // ラベル表示
            m.bindTooltip(`${p.id}`, {
                permanent: true, 
                direction: 'right', 
                className: 'rad-label', 
                offset: [10, 0]
            });

            // ポップアップ編集メニュー
            const dis = (p.type === 'RWY') ? 'disabled' : '';
            const html = `
                <div class="editor-popup">
                    <label>ID</label>
                    <input type="text" id="ed-id-${i}" value="${p.id}" ${dis} onchange="checkDb(${i})">
                    <label>ALT</label>
                    <input type="number" id="ed-alt-${i}" value="${p.altConstraint || ''}">
                    <div class="editor-btn-row">
                        <button class="btn-upd" onclick="saveWpt(${i})">UPD</button>
                        <button class="btn-del" style="${p.type === 'RWY' ? 'display:none' : ''}" onclick="deleteWpt(${i})">DEL</button>
                    </div>
                </div>`;
            m.bindPopup(html);

            // ドラッグイベント
            m.on('drag', e => {
                const np = e.target.getLatLng();
                flightPlan[i].lat = np.lat;
                flightPlan[i].lon = np.lng;
                updateSys();
            });
            m.on('dragend', updateSys);

            markers.push(m);
        });
    }

    // --- 測定系 ---
    function calcMeasure() {
        const fObj = resolveMInput(document.getElementById('m-from').value);
        const tObj = resolveMInput(document.getElementById('m-to').value);
        const fAlt = parseFloat(document.getElementById('m-from-alt').value);
        const tAlt = parseFloat(document.getElementById('m-to-alt').value);
        let mCoords = { from: fObj, to: tObj };
        if(fObj && tObj) {
            const d = getDist(fObj.lat, fObj.lon, tObj.lat, tObj.lon);
            const b = getBrg(fObj.lat, fObj.lon, tObj.lat, tObj.lon);
            document.getElementById('m-dist').innerText = d.toFixed(1) + " NM";
            document.getElementById('m-brg').innerText = Math.round(b) + " °";
            let pathText = "---";
            if (!isNaN(fAlt) && !isNaN(tAlt)) {
                const angle = getPathAngle(fAlt, tAlt, d);
                pathText = angle.toFixed(1) + "°";
                document.getElementById('m-path').style.color = Math.abs(angle) > 3.5 ? '#ff3333' : '#00ff00';
            } else { document.getElementById('m-path').style.color = "#888"; }
            document.getElementById('m-path').innerText = pathText;
            
            measureLayer.clearLayers();
            const p1=[fObj.lat, fObj.lon]; const p2=[tObj.lat, tObj.lon];
            L.polyline([p1,p2], {color:'#ffcc00', weight:3, dashArray:'10,10', opacity:0.8}).addTo(measureLayer);
            L.marker(p1).addTo(measureLayer).bindTooltip("FROM",{permanent:true, className:'measure-label'});
            L.marker(p2).addTo(measureLayer).bindTooltip("TO",{permanent:true, className:'measure-label'});
            const mid=[(p1[0]+p2[0])/2, (p1[1]+p2[1])/2];
            L.marker(mid, {icon:L.divIcon({html:`<div style="color:#ffcc00; font-weight:bold; text-align:center;">${d.toFixed(1)}NM / ${Math.round(b)}°</div>`, iconSize:[120,20]})}).addTo(measureLayer);
        } else {
            document.getElementById('m-dist').innerText = "---"; document.getElementById('m-brg').innerText = "---"; document.getElementById('m-path').innerText = "---";
        }
    }
        function drawMeasure(coords, dist, brg) {
        measureLayer.clearLayers();
        const p1=[coords.from.lat, coords.from.lon]; 
        const p2=[coords.to.lat, coords.to.lon];
        
        L.polyline([p1,p2], {color:'#ffcc00', weight:3, dashArray:'10,10', opacity:0.8}).addTo(measureLayer);
        L.marker(p1).addTo(measureLayer).bindTooltip("FROM",{permanent:true, direction:'top', className:'measure-label'});
        L.marker(p2).addTo(measureLayer).bindTooltip("TO",{permanent:true, direction:'top', className:'measure-label'});
        
        const mid=[(p1[0]+p2[0])/2, (p1[1]+p2[1])/2];
        L.marker(mid, {
            icon:L.divIcon({
                className: 'measure-result-icon', 
                html: `<div style="color:#ffcc00; font-weight:bold; font-size:13px; text-shadow:2px 2px 0 #000, -1px -1px 0 #000; text-align:center; white-space:nowrap;">${dist.toFixed(1)}NM / ${Math.round(brg)}°</div>`,
                iconSize: [160, 20],
                iconAnchor: [80, 10]
            })
        }).addTo(measureLayer);
    }


    let measureStep = 0; function toggleMeasureMode() { measureStep = 0; }
    
    // --- イベントハンドラ ---
    map.on('click', function(e) {
        if (!document.getElementById('chk-measure-mode').checked) return;
        const snap = getSnapPoint(e.latlng.lat, e.latlng.lng, true);
        if(measureStep === 0) {
            document.getElementById('m-from').value = snap.name; measureLayer.clearLayers();
            L.marker([snap.lat, snap.lon]).addTo(measureLayer).bindTooltip("FROM", {permanent:true, className:'measure-label'}); measureStep = 1;
        } else { document.getElementById('m-to').value = snap.name; calcMeasure(); measureStep = 0; }
    });
    map.on('dblclick', function(e) {
        if (document.getElementById('chk-measure-mode').checked) return;
        const snap = getSnapPoint(e.latlng.lat, e.latlng.lng, false);
        let best=flightPlan.length-1; let minD=Infinity;
        for(let i=0; i<flightPlan.length-1; i++) {
            const p1=flightPlan[i]; const p2=flightPlan[i+1];
            const detour = getDist(p1.lat, p1.lon, snap.lat, snap.lon) + getDist(snap.lat, snap.lon, p2.lat, p2.lon) - getDist(p1.lat, p1.lon, p2.lat, p2.lon);
            if(detour<minD){ minD=detour; best=i+1; }
        }
        flightPlan.splice(best, 0, { id: snap.name, lat: snap.lat, lon: snap.lon, altConstraint: null, type: 'WPT' });
        updateSys();
    });

    // --- ボタンアクション ---
    function addFromDb() {
    const val = document.getElementById('wpt-search').value.toUpperCase().trim();
    if(val==="") return;

    // ★修正: 統合検索を使用
    const pt = searchPoint(val);
    if (!pt) return; // 見つからなければ終了

    flightPlan.splice(flightPlan.length-1,0, {
        id: pt.id, 
        lat: pt.lat, 
        lon: pt.lon, 
        altConstraint: null, 
        type: pt.type 
    });
    updateSys(); document.getElementById('wpt-search').value="";
}

    window.setDest = function() {
    const val = document.getElementById('dest-search').value.toUpperCase().trim();
    if(val === "") return;
    let newRwy = null;

    // ★修正: 統合検索を使用
    const pt = searchPoint(val);
    if(pt) {
        newRwy = { id: pt.id, lat: pt.lat, lon: pt.lon, altConstraint: 0, type: 'RWY' };
    } 
    else if(val.includes(",")) { 
        /* 座標直接入力の処理 (そのまま) */
        const p = val.split(","); 
        newRwy = { id: "RWY", lat: parseFloat(p[0]), lon: parseFloat(p[1]), altConstraint: 0, type: 'RWY' }; 
    }

    if(newRwy) {
        /* ...既存の更新処理... */
        if(flightPlan.length > 0 && flightPlan[flightPlan.length-1].type === 'RWY') flightPlan[flightPlan.length-1] = newRwy;
        else flightPlan.push(newRwy);
        document.getElementById('dest-search').value = ""; updateSys(); map.setView([newRwy.lat, newRwy.lon], 9);
    } else { alert("DEST NOT FOUND IN DB"); }
}


    window.clearAllWpt = function() {
        if(!confirm("CLEAR ALL WPT (KEEP DEST)?")) return;
        if(flightPlan.length > 0) { const rwy = flightPlan[flightPlan.length - 1]; flightPlan = [ rwy ]; updateSys(); }
    }
   window.saveWpt = function(idx) {
        const nid = document.getElementById(`ed-id-${idx}`).value.toUpperCase();
        const nal = document.getElementById(`ed-alt-${idx}`).value;
        flightPlan[idx].id=nid; flightPlan[idx].altConstraint=nal===""?null:parseInt(nal);
        
        // ★修正: searchPoint を使って座標とタイプを更新
        const pt = searchPoint(nid);
        if(pt && flightPlan[idx].type!=='RWY'){ 
            flightPlan[idx].lat = pt.lat; 
            flightPlan[idx].lon = pt.lon;
            flightPlan[idx].type = pt.type; // アイコン種別も更新
        }
        map.closePopup(); updateSys();
    }

    window.deleteWpt = function(idx){ flightPlan.splice(idx,1); map.closePopup(); updateSys(); }
    window.checkDb = function(idx){
        const v = document.getElementById(`ed-id-${idx}`).value.toUpperCase();
        const el = document.getElementById(`ed-id-${idx}`);
        // ★修正: searchPoint で存在確認して枠色を変える
        el.style.border = searchPoint(v) ? "1px solid #00ff00" : "1px solid #555";
    }

    // --- WPTリスト描画 ---
    // --- WPTリスト描画 (削除ボタン付き) ---
    function renderWptList() {
        const container = document.getElementById('fms-seq-list');
        if (!container) return; 
        container.innerHTML = ""; 

        flightPlan.forEach((p, i) => {
            const row = document.createElement('div');
            row.className = 'wpt-row';
            
            const disUp = (i === 0) ? 'disabled' : '';
            const disDown = (i === flightPlan.length - 1) ? 'disabled' : '';
            const altVal = (p.altConstraint !== null && p.altConstraint !== undefined) ? p.altConstraint : "";
            
            // 最後の行(目的地)は削除させないようにする
            const isLast = (i === flightPlan.length - 1);
            const delVisibility = isLast ? 'visibility:hidden' : '';

            row.innerHTML = `
                <div style="display:flex; align-items:center;">
                    <span style="color:#00ffff; margin-right:5px; width:15px;">${i+1}</span>
                    <span class="wpt-name" style="width:50px;">${p.id}</span>
                    <input type="number" class="wpt-alt-input" value="${altVal}" placeholder="ALT" step="100" onchange="updateListAlt(${i}, this.value)">
                </div>
                <div>
                    <button class="btn-move" ${disUp} onclick="moveWpt(${i}, -1)">▲</button>
                    <button class="btn-move" ${disDown} onclick="moveWpt(${i}, 1)">▼</button>
                    <button class="btn-del-list" style="${delVisibility}" onclick="deleteWptFromList(${i})">×</button>
                </div>
            `;
            container.appendChild(row);
        });
    }
    
    // ★追加: 地図上にレグ間距離を描画
    function drawMapLegDistances() {
        distLabelLayer.clearLayers(); // 前回の描画をクリア

        for(let i = 0; i < flightPlan.length - 1; i++) {
            const p1 = flightPlan[i];
            const p2 = flightPlan[i+1];

            // 距離計算
            const d = getDist(p1.lat, p1.lon, p2.lat, p2.lon);

            // 中間地点計算
            const midLat = (p1.lat + p2.lat) / 2;
            const midLon = (p1.lon + p2.lon) / 2;

            // ラベル作成 (divIconを使用)
            const icon = L.divIcon({
                className: '', // デフォルトのスタイルを無効化
                html: `<div class="leg-dist-label">${d.toFixed(1)}</div>`,
                iconSize: [40, 12],
                iconAnchor: [20, 6] // 中心に合わせる
            });

            // マーカー配置 (操作不可 interactive: false)
            L.marker([midLat, midLon], {icon: icon, interactive: false}).addTo(distLabelLayer);
        }
    }

    window.moveWpt = function(index, direction) {
        const targetIndex = index + direction;

        // 配列の範囲外なら何もしない
        if(targetIndex < 0 || targetIndex >= flightPlan.length) return;

        // 配列の中身を入れ替え
        const temp = flightPlan[index];
        flightPlan[index] = flightPlan[targetIndex];
        flightPlan[targetIndex] = temp;

        // システム更新（ここでリストも再描画される）
        updateSys();
    };

    // ★追加: リストからの削除実行
    window.deleteWptFromList = function(index) {
        // 念のため確認
        // if(!confirm("DELETE " + flightPlan[index].id + "?")) return; 

        // 配列から削除
        flightPlan.splice(index, 1);
        
        // システム更新（再描画）
        updateSys();
    };

    // ★追加: リストからの高度更新
    window.updateListAlt = function(index, value) {
        // 空白なら制限なし(null)、数値なら整数に変換
        if (value.trim() === "") {
            flightPlan[index].altConstraint = null;
        } else {
            flightPlan[index].altConstraint = parseInt(value);
        }
        
        // グラフと地図を更新
        updateSys();
    }; // ←セミコロン忘れずに！


    // Grid
    // --- Grid (距離円) 描画システム ---
    
    let customGridCenter = null; // ユーザー指定の中心があれば格納

    // Gridを描画する関数
    function drawGrid() {
        dmeGrp.clearLayers(); // 前の円を消す

        // 中心決定ロジック:
        // 1. ユーザー指定があればそれを使う
        // 2. なければプランの最後(目的地)を使う
        let center = customGridCenter;
        if (!center && flightPlan.length > 0) {
            center = flightPlan[flightPlan.length - 1];
        }

        // 中心が決まらなければ何もしない
        if (!center) return;

        const m = 1852; // 1NM = 1852m
        
        // 中心点に十字マークを表示 (目的地以外の場合のみ分かりやすく表示)
        if (customGridCenter) {
            L.marker([center.lat, center.lon], {
                icon: L.divIcon({
                    className: '',
                    html: '<div style="color:#444; font-size:20px; text-align:center; margin-top:-14px;">+</div>',
                    iconSize: [20, 20]
                })
            }).addTo(dmeGrp);
        }

        // 5NM〜40NMまで5NM刻みで円を描く
        for(let n=10; n<=100; n+=10){
            L.circle([center.lat, center.lon], {
                radius: n * m, 
                color: '#444', 
                weight: 1, 
                dashArray: '4,8', 
                fill: false
            }).addTo(dmeGrp);
            
            // 距離ラベル (北側に配置)
            L.marker([center.lat + (n/60), center.lon], {
                icon: L.divIcon({
                    className: 'dme-txt', 
                    html: `<span style="font-family:monospace; font-weight:bold; color:#666; text-shadow:1px 1px 0 #000;">${n}</span>`, 
                    iconSize: [30, 12]
                })
            }).addTo(dmeGrp);
        }
    }

    // Grid中心を設定する関数
    window.setGridCenter = function() {
        const val = document.getElementById('grid-center-input').value.toUpperCase().trim();
        
        // 空欄でSETされたら「リセット（目的地に戻す）」
        if (val === "") {
            customGridCenter = null;
            updateSys(); // 再描画
            return;
        }

        // 統合検索(searchPoint)で場所を探す
        const pt = searchPoint(val);
        if (pt) {
            customGridCenter = { lat: pt.lat, lon: pt.lon, id: pt.id };
            document.getElementById('grid-center-input').value = pt.id; // 入力を正規化
            updateSys(); // 再描画
        } else {
            alert("WPT NOT FOUND");
        }
    }


    updateSys();
</script>
</body>
</html>